STSimulate.hs and the files in the SimulatorLib directory implement a
functional simulator for Aetherling pipelines: this simulator does not
concern itself with the actual timing of the circuit, but instead
works with "streams" of input/output values that have a precise
ordering but not precisely specified timing. This document describes:

1. How to use the simulator
2. How to extend the simulator with a combinational leaf op
3. Summary of simulator implementation
4. How to extend the simulator with a custom op
5. How to handle the SimhlState data type.



    1. How to Use the Simulator

simulateHighLevel (imported from STSimulate) is the function to call
for the simulator; all other functions defined are internal functions.
This function takes three arguments:
  a. The Op instance to simulate
  b. simulated input port values
  c. simulated memory input values
and returns a tuple of
  a. output port values
  b. memory output values
Except for the Op argument, all are lists-of-lists of ValueType.

The ValueType data type was created to facilitate passing data into
and out of the simulator. For each TokenType there is a corresponding
ValueType constructor that takes a single parameter for its value (Int
for V_Int, Bool for V_Bit, [ValueType] for V_Array; note that V_Array
does not have a length or type parameter).

The outer list of the input ports argument (or output ports return
value) corresponds to the list of input ports (or output ports), and
the inner list corresponds to the stream of values read from that
port. For example, in

> inputs = [[V_Int 0, V_Int 2, V_Int 4], [V_Int 30, V_Int 20, V_Int 10]]
> simulateHighLevel (Add T_Int) inputs [] -- Empty memory argument
([[V_Int 30,V_Int 22,V_Int 14]],[])

we simulate a 2-input-port adder, where the 0th input port gets 0, 2,
4 as its input stream and the 1st port 30, 20, 10. If this circuit
were timed at 1 output per clock cycle, then this simulation
corresponds to an adder calculating 0+30=30, 2+20=22, 4+10=14 on the
0th, 1st, and 2nd clock cycles.

As mentioned the simulator does not concern itself with exact timing,
so the lengths of the inner lists need not match. Example:

> add4stream = ArrayReshape [T_Int] [T_Array 1 T_Int] |>>=| ReduceOp 1 4 (Add T_Int)
> pipeline = (add4stream |&| Underutil 4 (Shl 4 T_Int)) |>>=| Underutil 4 (Max T_Int)
> :{
| inputs =
|         [ [V_Int 1, V_Int 2, V_Int 3, V_Int 4, V_Int 5, V_Int 6, V_Int 7, V_Int 8],
|           [V_Int 0, V_Int 10] ]
| :}
> simulateHighLevel pipeline inputs []
([[V_Int 10,V_Int 160]],[])

Here, we get [max (1+2+3+4) (0 shl 4), max (5+6+7+8) (10 shl 4)] as
the output stream. No action needed to be taken by the user to match
the V_Int 10 argument with the ...V_Int 5, V_Int 6, V_Int 7, V_Int 8]
arguments.

The memory input/output format is similar: the outer list entries
correspond to the MemRead/MemWrites and each inner list represents the
stream of values on one MemRead/MemWrite. The MemReads and MemWrites
are matched with outer list entries by the order that they would be
encountered by a depth first search of the pipeline AST. Example:

> :{
| pipeline =
|   (MemRead T_Bit |&| MemRead T_Bit) |>>=|
|   ArrayReshape [T_Bit, T_Bit] [T_Array 2 T_Bit] |>>=|
|   MapOp 2 ((MemRead T_Bit |&| Not T_Bit) |>>=| XOr T_Bit)
| inputs =
|           [ [V_Bit True, V_Bit False],
|             [V_Bit False, V_Bit True],
|             [V_Bit True, V_Bit False],
|             [V_Bit True, V_Bit False] ]
| :}
> simulateHighLevel pipeline [] inputs
([[V_Array [V_Bit True,V_Bit False],V_Array [V_Bit True,V_Bit False]]],[])

This pipeline compares memory inputs 0 and 2 and memory inputs 1 and 3
for equality, emitting the result of the 2 comparisons as a
2-array. The MemReads are numbered using the following logic:

ComposeSeq:
  ComposePar:
    Encounter 2 MemRead T_Bit: inputs 0 and 1.
  ArrayReshape: No MemReads.
  MapOp:
    Encounter 2 parallel copies of MemRead T_Bit: inputs 2 and 3.

This is not the most elegant solution to the issue of handling memory IO.



    2. How to Extend the Simulator with a Combinational Leaf Op.

Suppose that a new Op is added to STAST.hs and it needs to be
implemented in the simulator. This can easily be done without
understanding the simulator internals if the new Op is combinational
and contains no child Ops. Steps:

a. Write a [ValueType]->[ValueType] function that simulates the
   behavior of the Op (Foo) in one clock cycle: the input is a list of
   inputs for each input port and the output is similar. For example,
   conceptually the function for add should do [x, y] -> [x+y]. For
   certain patterns, helpers like simhlBinaryOp can further simplify
   this task. By convention the new function should be in a file in
   the SimulateLib directory and its name should be something like
   simhlFoo (simhl = simulate high level).

b. In the list of simhl pattern matches in STSimulate.hs, add an entry
   that looks something like

simhl Foo inStrs state = (simhlCombinational simhlFoo inStrs, state)

   Basically, for the first value of the tuple, simhlCombinational
   takes your function as an argument and adapts it to work with the
   simulator, and the second value is the state parameter passed
   through without modification (don't worry about it).

c. In the list of simhlPre pattern matches, add an entry that looks
   like

simhlPre opStack@(Foo:_) inStrLens inState =
    simhlPreCombinational opStack inStrLens inState



3. Summary of Simulator Implementation

When simulateHighLevel is called, it delegates its work to 3 functions:

a. simhlCheckInputs, which checks that the port inputs match with the
   inPorts of the simulated Op.

b. simhlPre, which recursively "preprocesses" the AST of the Op in order to:
   1. Calculate the intermediate stream lengths, using this for
      warnings about mismatched stream lengths and to find the maximum
      stream length, which is needed by the Constant_Int/_Bit ops.
   2. Check that the memory inputs match the types and count of
      MemRead ops.
   3. Check that the Ops in the pipeline are well-formed, producing
      warnings or errors if needed.

c. simhl, which performs the actual simulation, calling itself
   recursively if needed.
